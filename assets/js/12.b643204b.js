(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{360:function(e,t,r){"use strict";r.r(t);var a=r(42),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"mock-data"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mock-data"}},[e._v("#")]),e._v(" Mock Data")]),e._v(" "),r("p",[e._v("Mock 数据是前端开发过程中必不可少的一环，是分离前后端开发的关键链路。通过预先跟服务器端约定好的接口，模拟请求数据甚至逻辑，能够让前端开发更加独立自主，不会被服务端的开发所阻塞。")]),e._v(" "),r("h2",{attrs:{id:"swagger"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#swagger"}},[e._v("#")]),e._v(" Swagger")]),e._v(" "),r("p",[e._v("在公司的项目中通常使用 "),r("a",{attrs:{href:"https://swagger.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("swagger"),r("OutboundLink")],1),e._v("， 由后端来模拟业务数据。\n"),r("strong",[e._v("swagger")]),e._v(" 是一个 REST APIs 文档生成工具，它从代码注释中自动生成文档，可以跨平台，开源，支持大部分语言，社区好，总之非常不错，强烈推荐。\n"),r("a",{attrs:{href:"http://petstore.swagger.io/?_ga=2.222649619.983598878.1509960455-2044209180.1509960455#/pet/addPet",target:"_blank",rel:"noopener noreferrer"}},[e._v("线上 demo"),r("OutboundLink")],1)]),e._v(" "),r("h2",{attrs:{id:"mockjs"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mockjs"}},[e._v("#")]),e._v(" Mockjs")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/nuysoft/Mock",target:"_blank",rel:"noopener noreferrer"}},[e._v("mockjs"),r("OutboundLink")],1),e._v(" 的原理是: 拦截了所有的请求并代理到本地，然后进行数据模拟，所以你会发现 "),r("code",[e._v("network")]),e._v(" 中没有发出任何的请求。")]),e._v(" "),r("p",[e._v("但它的最大的问题是就是它的实现机制。它会重写浏览器的"),r("code",[e._v("XMLHttpRequest")]),e._v("对象，从而才能拦截所有请求，代理到本地。大部分情况下用起来还是蛮方便的，但就因为它重写了"),r("code",[e._v("XMLHttpRequest")]),e._v("对象，所以比如"),r("code",[e._v("progress")]),e._v("方法，或者一些底层依赖"),r("code",[e._v("XMLHttpRequest")]),e._v("的库都会和它发生不兼容。")]),e._v(" "),r("p",[e._v("它还有一个问题是，因为是它本地模拟的数据，实际上不会走任何网络请求。所以本地调试起来很蛋疼，只能通过"),r("code",[e._v("console.log")]),e._v("来调试。")]),e._v(" "),r("h2",{attrs:{id:"目前方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#目前方案"}},[e._v("#")]),e._v(" 目前方案")]),e._v(" "),r("p",[e._v("在本地会启动一个"),r("code",[e._v("mock-server")]),e._v("来模拟数据，该方案的好处是，在保留 "),r("code",[e._v("mockjs")]),e._v("的优势的同时，解决之前的痛点。由于我们的 mock 是完全基于"),r("code",[e._v("webpack-dev-serve")]),e._v("来实现的，所以在你启动前端服务的同时，"),r("code",[e._v("mock-server")]),e._v("就会自动启动，而且这里还通过 "),r("a",{attrs:{href:"https://github.com/paulmillr/chokidar",target:"_blank",rel:"noopener noreferrer"}},[e._v("chokidar"),r("OutboundLink")],1),e._v(" 来观察 "),r("code",[e._v("mock")]),e._v(" 文件夹内容的变化。在发生变化时会清除之前注册的"),r("code",[e._v("mock-api")]),e._v("接口，重新动态挂载新的接口，从而支持热更新。有兴趣的可以自己看一下代码"),r("a",{attrs:{href:"https://github.com/MapGIS/MapGIS-Pan-Spatial-Map/blob/master/packages/pan-spatial-map-mock-server/mock/mock-server.ts",target:"_blank",rel:"noopener noreferrer"}},[e._v("mock-server.ts"),r("OutboundLink")],1),e._v("。由于是一个真正的"),r("code",[e._v("server")]),e._v("，所以你可以通过控制台中的"),r("code",[e._v("network")]),e._v("，清楚的知道接口返回的数据结构。并且同时解决了之前"),r("code",[e._v("mockjs")]),e._v("会重写 "),r("code",[e._v("XMLHttpRequest")]),e._v("对象，导致很多第三方库失效的问题。")]),e._v(" "),r("h2",{attrs:{id:"移除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#移除"}},[e._v("#")]),e._v(" 移除")]),e._v(" "),r("p",[e._v("如果你不想使用"),r("code",[e._v("mock-server")]),e._v("的话只要在"),r("a",{attrs:{href:"https://github.com/MapGIS/MapGIS-Pan-Spatial-Map/blob/master/packages/pan-spatial-map-plugin-auth/src/templates/src/statics/plugins/auth/config.json",target:"_blank",rel:"noopener noreferrer"}},[e._v("config.json"),r("OutboundLink")],1),e._v("中修改"),r("code",[e._v('"^/onemap"')]),e._v("指向实际的全空间一张图服务器地址就可以了。")]),e._v(" "),r("h2",{attrs:{id:"新增"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#新增"}},[e._v("#")]),e._v(" 新增")]),e._v(" "),r("p",[e._v("如果你想添加 mock 数据，只要在"),r("code",[e._v("packages/pan-spatial-map-mock-server")]),e._v("根目录下找到"),r("code",[e._v("mock")]),e._v("文件，添加对应的路由，对其进行拦截和模拟数据即可。")])])}),[],!1,null,null,null);t.default=o.exports}}]);